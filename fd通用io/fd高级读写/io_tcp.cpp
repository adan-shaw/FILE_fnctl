//111111111111111111111111111111111111111111111111111111111111111111111111
//格式测试:
//邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵邵
//起始日期:
//完成日期:
//************************************************************************
//修改日志:
//	2019-05-13: 新增'tty 文本标准格式'风格
//, , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,, , ,


//编译:
//g++ -o x ./io_basic.cpp -g3

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h> // for 原子操作O_RDONLY 之类的
#include <unistd.h>



//通用io 对tcp socket 流式数据进行通用io 处理！！


//关键1: socket缓冲区, write()/read() 与send()/recv() 的区别
/*
	每个socket被创建后, 都会分配两个缓冲区, 输入缓冲区和输出缓冲区.
	write()/send() 并不立即向网络中传输数据, 而是先将数据写入缓冲区中,
	再由TCP协议将数据从缓冲区发送到目标机器.
	一旦将数据写入到缓冲区, 函数就可以成功返回,
	不管它们有没有到达目标机器, 也不管它们何时被发送到网络,
	这些都是TCP协议负责的事情.

	TCP协议独立于write()/send() 函数,
	数据有可能刚被写入缓冲区就发送到网络,
	也可能在缓冲区中不断积压,
	多次写入的数据被一次性发送到网络,
	这取决于当时的网络情况、当前线程是否空闲等诸多因素, 不由程序员控制.

	read()/recv() 函数也是如此, 也从输入缓冲区中读取数据,
	而不是直接从网络中读取.



	这些I/O缓冲区特性可整理如下：
		1.I/O缓冲区在每个TCP套接字中单独存在;
		2.I/O缓冲区在创建套接字时自动生成;
		3.即使关闭套接字也会'继续传送输出缓冲区'中遗留的数据;
		4.关闭套接字将'丢失输入缓冲区'中的数据.

	输入输出缓冲区的默认大小一般都是8K,可以通过 getsockopt()函数获取.


	如果write()写入的数据大于socket缓冲区,则:
	TCP:
		1,阻塞fd将会阻塞直到可以发出,
			如果超过MTU将会分片, 这些你都不需要关心, 你发多长的数据都行,
			不会因为数据长而导致致命的错误, 会自动分片.
		2,非阻塞fd将会返回-1,errno=EAGAIN=再次尝试可能会成功,网卡可能会空闲
	UDP:
		1,阻塞fd, 如果网卡满会阻塞, 如果超过UDP最大包限制将会出错返回-1.
		2,非阻塞fd, 网卡满返回-1,errno=EAGAIN. 超过UDP最大包限制一样
	另外:
		由于读写缓冲区, 是分立的,
		且默认一个socket 同一时间, 只能有一个io 操作在进行,
		所以, 理论上可以‘默认单次最大’写入8kb 数据,
		(但是如果写入时, 网卡未空闲, 上一次数据未发出去, 下一波数据又来了
			这种情况是需要程序员极力避免的'资源竞争冲突')
	粘包:
		epoll 有两种模式, ET模式
		ET模式:
			仅当状态发生变化的时候才获得通知,
			这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,
			也就是说,如果要采用ET模式,需要一直read/write直到出错为止,
			很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了;
		LT模式:
			是只要有数据没有处理就会一直通知下去的.

		但无论那种模式, 都可能出发'粘包问题';
		例如:
			用epoll监听read事件, 第一次收到epoll read通知, 再去读数据,
			数据未读完, 第二波数据又来了.
			通知仍然不断拥入, 但此时, 你还未退出读取循环.
			就会连第二波的数据, 也读进了装载第一次read 的缓冲区中.
		粘包解决办法1:
			固定每一次数据缓冲区的长度, 补足则填充.
		粘包解决办法2:(这个方法可行)
			分两次发送数据,
			第一次是固定的数据信息元, 格式, 长度固定.
			第二次是数据体, 长度由第一次固定信息元提供.
			传输保证, by来自tcp 协议对数据安全完整传输的可靠性!

*/

//通用io 的write()/read() 与send()/recv() 的区别(测试函数)
void io_tcp_socket(void){
	int fd_srv,fd_cli,tmp;





}



int main(void){
	//1.通用io 的write()/read() 与send()/recv() 的区别.
	io_tcp_socket();

	return 0;
}
