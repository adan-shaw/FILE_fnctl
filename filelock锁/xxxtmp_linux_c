你要明白, 并发写, 并不需要加锁?? 那么可能出现乱序???
还是系统会自动?? 对的, 系统会自动安排,,, 因为有buf !!
所以有缓冲, 所以你可以乱写...

劝戒锁, 强制锁. 要区分, 与内存锁的区别.



并发读, 随意, 乱来都行.
并发写, 也随意, 乱来都行, 控制好文件流就可以了.

多进程读, 多进程写, 就是问题了, 因为不能共享流.
所以单一线程的, 都是劝戒锁, 你可以强制操作.


多线程, 多进程完全是不一样的世界.


读写冲突时, 数据的准确性有很大问题, 就算是多线程, 也需要上强制锁. 多进程也是.



如果flockfile 是锁住一个FILE* io 流, 也就是锁住io缓冲区;
flock 却是锁住文件实体.

fcntl 应该也是锁住io 流, 因为fcntl 本身就是对FILE* 负责的, 但是fcntl 可以做到行锁, 更精确一些








你还要想办法```改改文件权限,,, 用C 语言～～改改访问权限, 不要让其他人随意访问你的数据缓存!! 
这才是策略～～

还要指定好存放位置！！ 还要会修改文件名!! 因为这些都是比较重要的,,, 这些都另外弄一个demo,,, 应该不难



你的这些操作, 在操作xml and json 到本地的时候, 都是有用的, 当然你可以选择导入到mysql 里面,
但是mysql 同样需要读取dick, 还要经过network,,, 应该理论上比直接写盘, 慢太多了!!
而且消耗资源也更多.

但是聪明的, 可以利用redis 来避免这些问题, 或者是本地mysql 来避免问题.
redis 比较聪明些, 但是有丢失的风险





你必须整理好这个基础的概念!!!!


文件描述符fd: 控制访问, 权限, 存放位置等信息, ioctl(), 实写同步io
无缓冲区可言, 直接冲写到磁盘, 加锁必须是整个文件加锁, 强制锁.


流描述符FILE*: IO 缓冲控制, 缓冲池定位, 缓冲区大小等, 也可以加缓冲锁, 即IO 流锁.
其实现, 是锁住流结构体







