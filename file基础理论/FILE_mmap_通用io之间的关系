1.FILE
	FILE 文件流, 实际是通用io 的基础上, 再加上一个应用层的文件流机制,
	包括流缓冲区, 流自动冲刷, 还有各种流标准API, 这都是一种资源.
	另外: 流本身就是'fd 通用io'的超集, 所以FILE 流也会集成'fd 通用io'所有功能.


2.fd 通用io
	linux fd 通用io, 有7种文件类型可供读写, 包括普通文件(文本, 二进制块, 应用数据), 
	包括设备, 包括目录, 链接等等.

	fd 通用io 是系统操作磁盘, 网卡, 设备, 任何设备的基石, 一切皆文件, 指的就是'fd 通用io'.
	FILE 流只是'fd 通用io'基础上, 对磁盘管理的封装.
	'fd 通用io'却不一定是磁盘设备!!

	当然, 就算你用'fd 通用io'对磁盘进行直写操作, 除非你严正声明, 要求系统马上写盘,
	否则系统默认还是会有缓写机制, 后写机制, 数据都会被系统调度, 集中之后再写.
	但你也可以命令'fd 通用io'直写, 每次执行之后, 都直接冲刷.


3.mmap 虚拟内存映射
	虚拟内存映射, 使得应用数学写盘的时候, 可以实现“内核态读写(拷贝)”.
	sendfile(), DMA 机制等, 实际都是利用mmap的原理实现的,
	所以: sendfile() 函数调用的时候, 也会要求可以使用mmap 才能用.

	mmap 虚拟内存映射, 
	实际就是‘进程’从‘系统虚拟内存地址’中分配得到的’虚拟内存域‘直接映射到设备的一种技术.
	’虚拟内存域‘->磁盘, 就是mmap
	’虚拟内存域‘->网卡, 就是sendfile
	’虚拟内存域‘->unknow device, 就是DMA技术!!

	注意: 虚拟内存地址, 是操作系统统一管理的, 一个OS 只有一片虚拟内存地址!!
				32bit 系统, 虚拟内存大小是4GB, 64 bit 系统, 虚拟内存大小是 2^64 次方.
				因此, 应用程序分配到的虚拟内存地址, 实际上是系统统一分配的.

	另外: 虚拟内存映射到RAM 还是磁盘上, 都是可以的, 这具体看你调用什么API 来操作.
				malloc() 实际就是在已知的"RAM-虚拟内存“映射中, 获取一块符合你大小需求的操作.
				mmap() 则管理两者, 你既可以将数据常驻RAM 内存中, 
				也可以写到磁盘中, 等到用的时候再调出来.


4.这三者FILE, fd, mmap 的主要区别是:
	FILE 面向磁盘, 带缓冲区读写, 
			 每次读写都需要write(),read()主动写入数据到磁盘中.
			 
	fd 面向通用设备, 可带可不带‘缓冲区读写’, 
		 每次读写都需要write(),read()主动写入数据到设备中.
		 
	mmap 面向磁盘, 不带缓冲区, 直接映射, 
			 也不需要write(),read(), 是自动算法冲刷或者手动冲刷数据到磁盘中

	一旦你调用了write(),read(), 就会是double copy 或者读取.
	因为你首先write(),read()的时候, 会直接写到buf 缓冲区中(fd 通用io 直写除外),
	然后再写到磁盘中.
	这样就会有这样的操作路线: 数据buf -> 读写流/系统自带的磁盘缓冲写buf -> 磁盘
	而mmap 直写是这样的: 虚拟内存地址(实体变量内存地址) -> 直接冲刷到磁盘.


	但是实际上, mmap 的主要作用是: 
		* 防止内存峰值期造成系统瘫痪.
		* 防止断电丢失数据
		* 减少内存的使用
		* 直接磁盘->网卡, 减少中间double copy !
		* 



